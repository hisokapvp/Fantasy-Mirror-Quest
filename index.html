<!-- ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð¸Ñ€Ð°Ð¹ Ð¾Ñ‚ ÐšÐ¾Ð¿Ð¸Ð»Ð¾Ñ‚Ð° -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mirror Protocol: Pathfinder Edition</title>
    <style>
        :root {
            --bg-color: #0b0f19;
            --panel-bg: rgba(20, 26, 40, 0.95);
            --border-color: #4a5d7e;
            --accent-gold: #c5a059;
            --accent-blue: #4db3ff;
            --beam-color: #ff3366;
            --beam-win: #00ffaa;
            --text-main: #e0e6ed;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Cinzel', 'Segoe UI', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            background-image: radial-gradient(circle at center, #1a253a 0%, #05070a 100%);
        }

        /* --- UI OVERLAYS --- */
        #main-menu, #rank-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 7, 10, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #main-menu {
            background: radial-gradient(circle at top, rgba(70, 120, 210, 0.35), transparent 55%),
                radial-gradient(circle at 20% 80%, rgba(255, 140, 60, 0.25), transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(140, 70, 255, 0.2), transparent 45%),
                rgba(5, 7, 10, 0.9);
            overflow: hidden;
        }

        .menu-backdrop {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }

        .menu-orb {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(77, 179, 255, 0.8), rgba(77, 179, 255, 0));
            filter: blur(2px);
            animation: floatOrb 12s ease-in-out infinite;
            opacity: 0.7;
        }

        .menu-orb.orb-a { top: 10%; left: 12%; animation-delay: 0s; }
        .menu-orb.orb-b { top: 65%; left: 70%; animation-delay: 2s; width: 200px; height: 200px; background: radial-gradient(circle, rgba(255, 110, 110, 0.7), rgba(255, 110, 110, 0)); }
        .menu-orb.orb-c { top: 30%; left: 78%; animation-delay: 4s; width: 120px; height: 120px; background: radial-gradient(circle, rgba(160, 255, 180, 0.7), rgba(160, 255, 180, 0)); }

        .menu-spark {
            position: absolute;
            width: 4px;
            height: 120px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(77, 179, 255, 0.7), rgba(255, 255, 255, 0));
            opacity: 0.6;
            animation: driftSpark 6s linear infinite;
        }

        .menu-spark.spark-a { left: 18%; top: -20%; animation-delay: 0s; }
        .menu-spark.spark-b { left: 52%; top: -30%; animation-delay: 2s; }
        .menu-spark.spark-c { left: 78%; top: -25%; animation-delay: 4s; }

        @keyframes floatOrb {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(20px, -30px) scale(1.08); }
        }

        @keyframes driftSpark {
            0% { transform: translateY(0); opacity: 0; }
            20% { opacity: 0.7; }
            80% { opacity: 0.4; }
            100% { transform: translateY(140vh); opacity: 0; }
        }

        .menu-window {
            background: linear-gradient(135deg, #1a2230 0%, #0f141e 100%);
            border: 2px solid var(--accent-gold);
            padding: 40px 60px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8), inset 0 0 20px rgba(197, 160, 89, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            min-width: 400px;
            position: relative;
            z-index: 1;
        }

        h1 {
            font-size: 2.5em;
            color: var(--accent-gold);
            text-shadow: 0 0 15px rgba(197, 160, 89, 0.5);
            margin-bottom: 20px;
            letter-spacing: 2px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            width: 100%;
        }

        .rank-info-box {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        .rank-current { font-size: 1.5em; margin-bottom: 5px; font-weight: bold; text-shadow: 0 0 10px currentColor; }
        .rank-next { color: #889; font-size: 0.9em; margin-top: 5px; }
        
        .xp-bar-container {
            width: 100%;
            height: 8px;
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #444;
            margin: 5px 0;
        }
        .xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #c5a059, #ffdb4d);
            width: 0%;
            transition: width 0.5s ease-out;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, rgba(77, 179, 255, 0.25) 0%, rgba(197, 160, 89, 0.25) 50%, rgba(31, 42, 64, 0.9) 100%);
            color: var(--accent-gold);
            border: 1px solid var(--border-color);
            padding: 12px 30px;
            font-family: inherit;
            font-size: 1.1em;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-transform: uppercase;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 0 18px rgba(77, 179, 255, 0.4), 0 0 30px rgba(197, 160, 89, 0.3);
            transform: translateY(-2px);
        }

        button::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.25), transparent);
            transform: translateX(-120%);
            transition: transform 0.5s ease;
        }

        button:hover::after {
            transform: translateX(120%);
        }
        
        .lang-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            width: 100%;
            justify-content: center;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }
        .lang-btn {
            width: auto;
            min-width: 60px;
            padding: 5px 10px;
            font-size: 0.9em;
            opacity: 0.6;
        }
        .lang-btn.active { opacity: 1; border-color: var(--accent-blue); background: #1f3a50; }

        #game-ui {
            display: none;
            flex-direction: column;
            align-items: center;
        }

        .hud-panel {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            font-size: 1.2em;
            background: var(--panel-bg);
            padding: 10px 30px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        .hud-item span { color: var(--accent-blue); font-weight: bold; }
        .score-val { color: var(--accent-gold) !important; }

        .hint-btn-game {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }
        .hint-btn-game:hover {
            background: rgba(77, 179, 255, 0.1);
            box-shadow: 0 0 10px var(--accent-blue);
        }

        #board-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 5px solid #2a3b55;
            border-radius: 8px;
        }

        #game-board {
            display: grid;
            gap: 1px;
            background: #111;
        }

        .cell {
            background: #1b2433;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default;
            position: relative;
            transition: background 0.2s;
        }
        
        .cell::before {
            content: '';
            position: absolute;
            width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
        }

        .mirror {
            width: 70%; height: 70%;
            background: linear-gradient(135deg, rgba(18, 25, 38, 0.95) 0%, rgba(65, 90, 125, 0.95) 45%, rgba(150, 210, 255, 0.8) 55%, rgba(34, 52, 74, 0.95) 100%);
            border: 1px solid #8aa6c2;
            box-shadow: 0 0 6px rgba(0,0,0,0.6), inset 0 0 12px rgba(120, 190, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s ease-out;
            z-index: 2;
            position: relative;
            overflow: hidden;
        }
        /* Visual Indicator for Mirror Angle */
        .mirror::after {
            content: '';
            position: absolute;
            width: 140%;
            height: 6px;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0), rgba(0, 220, 255, 0.9), rgba(0, 255, 255, 0));
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.9);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 6px;
        }

        .mirror::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.18) 0%, rgba(255, 255, 255, 0) 55%);
            opacity: 0.7;
        }
        
        .mirror.reflecting {
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.8), inset 0 0 15px rgba(0, 210, 255, 0.3);
            border-color: #b7e3ff;
        }
        
        .mirror[data-angle="0"] { transform: rotate(-45deg); } 
        .mirror[data-angle="1"] { transform: rotate(45deg); }
        .mirror[data-angle="2"] { transform: rotate(135deg); }
        .mirror[data-angle="3"] { transform: rotate(225deg); }

        .wall {
            width: 80%; height: 80%;
            background: #2a2a35;
            border: 2px solid #3a3a45;
            border-radius: 4px;
            box-shadow: inset 0 0 10px #000;
        }

        /* --- START EMITTER STYLING --- */
        .start-container {
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .start-icon { 
            font-size: 2em; 
            filter: drop-shadow(0 0 5px #0f0); 
            z-index: 3; 
            cursor: pointer; 
            transition: transform 0.25s ease-out;
            pointer-events: auto;
            transform: rotate(var(--start-rotate, 0deg));
            transform-origin: center;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .start-icon .icon-stack {
            position: relative;
            display: inline-block;
            width: 1em;
            height: 1em;
        }

        .start-icon .icon-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-origin: center;
        }

        .start-icon .icon-core.icon-rotated {
            transform: translate(-50%, -50%) rotate(90deg);
        }

        .start-icon.beam-active .icon-stack {
            animation: startJitter 0.2s infinite ease-in-out;
        }

        @keyframes startJitter {
            0% { transform: translate(0, 0) rotate(0deg); }
            20% { transform: translate(-1px, 1px) rotate(-3deg); }
            40% { transform: translate(1px, -1px) rotate(3deg); }
            60% { transform: translate(-1px, -1px) rotate(-2deg); }
            80% { transform: translate(1px, 1px) rotate(2deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        /* Hover Arrows */
        .start-arrows {
            position: absolute;
            width: 120%; height: 120%;
            display: none; /* Shown on hover */
            pointer-events: none;
            z-index: 4;
        }
        .start-container:hover .start-arrows { display: block; }

        .arrow-btn {
            position: absolute;
            width: 20px; height: 20px;
            background: rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 10px; font-weight: bold;
        }
        .arrow-btn:hover { background: #0f0; box-shadow: 0 0 10px #0f0; }
        
        .arr-up { top: -10px; left: 50%; transform: translateX(-50%); }
        .arr-down { bottom: -10px; left: 50%; transform: translateX(-50%); }
        .arr-left { left: -10px; top: 50%; transform: translateY(-50%); }
        .arr-right { right: -10px; top: 50%; transform: translateY(-50%); }

        /* End & Chest */
        .end { font-size: 1.5em; filter: drop-shadow(0 0 5px #f00); z-index: 2; }
        .end.lit { filter: drop-shadow(0 0 15px #0f0); transform: scale(1.2); transition: 0.5s; }
        
        .chest {
            font-size: 1.5em; 
            filter: drop-shadow(0 0 5px #ffd700); 
            z-index: 2;
        }
        .chest.open {
            filter: grayscale(100%);
            opacity: 0.5;
            transform: scale(0.8);
        }

        .monster {
            position: absolute;
            font-size: 1.5em;
            pointer-events: none;
            transition: top 0.5s linear, left 0.5s linear, opacity 0.3s;
            z-index: 3;
            filter: drop-shadow(0 0 5px #a0f);
        }
        .monster.dead {
            opacity: 0;
            transform: scale(1.5);
            filter: hue-rotate(90deg);
        }
        .float-score {
            position: absolute;
            color: #ff0;
            font-weight: bold;
            font-size: 1.2em;
            animation: floatUp 1s forwards;
            z-index: 10;
        }
        @keyframes floatUp { to { transform: translateY(-30px); opacity: 0; } }

        canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5; }

        /* Rank Screen */
        .rank-title { font-size: 2.5em; color: var(--beam-win); margin-bottom: 5px; text-shadow: 0 0 20px var(--beam-win); }
        .stats-row { display: flex; gap: 20px; font-size: 1.2em; color: #aaa; margin: 10px 0; }
        .stat-val { color: var(--accent-gold); font-weight: bold; }

    </style>
</head>
<body>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <div class="menu-backdrop">
            <div class="menu-orb orb-a"></div>
            <div class="menu-orb orb-b"></div>
            <div class="menu-orb orb-c"></div>
            <div class="menu-spark spark-a"></div>
            <div class="menu-spark spark-b"></div>
            <div class="menu-spark spark-c"></div>
        </div>
        <div class="menu-window">
            <h1 id="title-txt">PATHFINDER'S MIRROR</h1>
            
            <div class="rank-info-box">
                <div class="rank-current" id="menu-rank-cur">Lost Vagrant</div>
                <div class="xp-bar-container">
                    <div class="xp-bar-fill" id="menu-xp-bar"></div>
                </div>
            </div>
            
            <div class="btn-group">
                <button onclick="startGame(0)" id="btn-easy">Novice</button>
                <button onclick="startGame(1)" id="btn-norm">Scout</button>
                <button onclick="startGame(2)" id="btn-hard">Ranger</button>
            </div>

            <div class="lang-group">
                <button class="lang-btn active" id="btn-lang-ru" onclick="setLang('ru')">Ð Ð£</button>
                <button class="lang-btn" id="btn-lang-en" onclick="setLang('en')">ENG</button>
            </div>
        </div>
    </div>

    <!-- RANK / GAME OVER SCREEN -->
    <div id="rank-screen" style="display: none;">
        <div class="menu-window">
            <div class="rank-title" id="vic-title">VICTORY!</div>
            <div class="stats-row">
                <div id="vic-score-lbl">Score: <span class="stat-val" id="vic-score-val">0</span></div>
                <div id="vic-moves-lbl">Moves: <span class="stat-val" id="vic-moves-val">0</span></div>
            </div>
            <button onclick="showMenu()" id="btn-menu">Main Menu</button>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="game-ui">
        <div class="hud-panel">
            <div class="hud-item"><span id="lbl-score">Score:</span> <b class="score-val" id="score-val">1000</b></div>
            <div class="hud-item"><span id="lbl-moves">Moves:</span> <b id="moves-val">0</b></div>
            <div class="hud-item"><span id="lbl-mirrors">Mirrors:</span> <b id="mirrors-val">0</b></div>
            <div class="hud-item">
                <button class="hint-btn-game" onclick="toggleHint()" id="btn-hint" style="padding: 5px 15px; min-width: auto; font-size: 0.8em;">SHOW PATH</button>
            </div>
            <div class="hud-item">
                <button onclick="quitGame()" id="btn-exit" style="padding: 5px 15px; min-width: auto; font-size: 0.8em;">EXIT</button>
            </div>
        </div>
        
        <div id="board-container">
            <div id="game-board"></div>
            <canvas id="beam-canvas"></canvas>
            <div id="monsters-layer"></div>
        </div>
    </div>

<script>
    // --- TEXT DATA ---
    const TEXT = {
        en: {
            title: "PATHFINDER'S MIRROR",
            easy: "Novice",
            norm: "Scout",
            hard: "Ranger",
            score: "Energy:",
            moves: "Moves:",
            mirrors: "Mirrors:",
            hint: "SHOW PATH",
            exit: "EXIT",
            menu: "MAIN MENU",
            lang_ru: "RU",
            lang_en: "ENG",
            vic_title: "VICTORY!",
            vic_score: "Score: ",
            vic_moves: "Moves: ",
            ranks: [
                "Lost Vagrant", "Rat Catcher", "Tomb Raider", "Dungeon Scout", 
                "Keen Hunter", "Rune Seeker", "Shadow Stalker", "Master Pathfinder", 
                "Grand Architect", "Keeper of the Light"
            ]
        },
        ru: {
            title: "Ð—Ð•Ð ÐšÐÐ›Ðž Ð¡Ð›Ð•Ð”ÐžÐŸÐ«Ð¢Ð",
            easy: "ÐÐ¾Ð²Ð¸Ñ‡Ð¾Ðº",
            norm: "Ð Ð°Ð·Ð²ÐµÐ´Ñ‡Ð¸Ðº",
            hard: "Ð¡Ð»ÐµÐ´Ð¾Ð¿Ñ‹Ñ‚",
            score: "Ð­Ð½ÐµÑ€Ð³Ð¸Ñ:",
            moves: "Ð¥Ð¾Ð´Ñ‹:",
            mirrors: "Ð—ÐµÑ€ÐºÐ°Ð»Ð°:",
            hint: "ÐŸÐžÐšÐÐ—ÐÐ¢Ð¬ ÐŸÐ£Ð¢Ð¬",
            exit: "Ð’Ð«Ð¥ÐžÐ”",
            menu: "Ð“Ð›ÐÐ’ÐÐžÐ• ÐœÐ•ÐÐ®",
            lang_ru: "Ð Ð£",
            lang_en: "ÐÐÐ“",
            vic_title: "ÐŸÐžÐ‘Ð•Ð”Ð!",
            vic_score: "ÐžÑ‡ÐºÐ¸: ",
            vic_moves: "Ð¥Ð¾Ð´Ñ‹: ",
            ranks: [
                "Ð—Ð°Ð±Ð»ÑƒÐ´ÑˆÐ¸Ð¹ Ð‘Ñ€Ð¾Ð´ÑÐ³Ð°", "ÐšÑ€Ñ‹ÑÐ¾Ð»Ð¾Ð²", "Ð Ð°ÑÑ…Ð¸Ñ‚Ð¸Ñ‚ÐµÐ»ÑŒ Ð“Ñ€Ð¾Ð±Ð½Ð¸Ñ†", "ÐŸÐ¾Ð´Ð·ÐµÐ¼ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð Ð°Ð·Ð²ÐµÐ´Ñ‡Ð¸Ðº",
                "Ð—Ð¾Ñ€ÐºÐ¸Ð¹ ÐžÑ…Ð¾Ñ‚Ð½Ð¸Ðº", "Ð˜ÑÐºÐ°Ñ‚ÐµÐ»ÑŒ Ð ÑƒÐ½", "Ð¡ÑƒÐ¼ÐµÑ€ÐµÑ‡Ð½Ñ‹Ð¹ Ð¡Ñ‚Ð°Ð»ÐºÐµÑ€", "ÐœÐ°ÑÑ‚ÐµÑ€ Ð¡Ð»ÐµÐ´Ð¾Ð¿Ñ‹Ñ‚",
                "Ð’ÐµÐ»Ð¸ÐºÐ¸Ð¹ ÐÑ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚Ð¾Ñ€", "Ð¥Ñ€Ð°Ð½Ð¸Ñ‚ÐµÐ»ÑŒ Ð¡Ð²ÐµÑ‚Ð°"
            ]
        }
    };
    
    // Rank Colors
    const RANK_COLORS = ["#7f8c8d", "#8e44ad", "#2980b9", "#27ae60", "#d35400", "#c0392b", "#f1c40f", "#00d2ff", "#ff00ff", "#ffd700"];

    let curLang = 'ru';

    // --- CONFIG ---
    const CELL_SIZE = 50; 
    const GAP = 1;
    
    let totalXP = localStorage.getItem('mirror_quest_xp_v3') ? parseInt(localStorage.getItem('mirror_quest_xp_v3')) : 0;
    const RANK_THRESHOLDS = [0, 5000, 15000, 30000, 50000, 80000, 120000, 170000, 250000, 500000];

    const LEVELS = [
        { size: 8,  pathLen: 6,  startScore: 2000, moveCost: 40, monsterCount: 1, chestCount: 1, xpRewardFactor: 0.5, placeableMirrors: 2, generatedMirrors: { min: 5, max: 7 } },
        { size: 10, pathLen: 10, startScore: 4000, moveCost: 80, monsterCount: 2, chestCount: 2, xpRewardFactor: 0.5, placeableMirrors: 4, generatedMirrors: { min: 8, max: 11 } },
        { size: 12, pathLen: 16, startScore: 8000, moveCost: 150, monsterCount: 3, chestCount: 3, xpRewardFactor: 0.5, placeableMirrors: 6, generatedMirrors: { min: 12, max: 15 } }
    ];

    const DIRS = { 'UP': {dx:0, dy:-1}, 'DOWN': {dx:0, dy:1}, 'LEFT': {dx:-1, dy:0}, 'RIGHT': {dx:1, dy:0} };
    const DIR_NAMES = ['UP', 'RIGHT', 'DOWN', 'LEFT']; 

    // --- STATE ---
    let grid = [];
    let monsters = [];
    let chests = [];
    let solutionPath = []; 
    let showHintOverlay = false;
    let beamActive = false;
    let curLevelIdx = 0;
    let boardSize = 8;
    
    let startPos = {};
    let endPos = {};
    
    let score = 0;
    let moves = 0;
    let isWin = false;
    let monsterInterval = null;
    let beamAnimFrame = null;
    let beamPulse = 0;
    let startRotation = 0;
    let remainingPlaceableMirrors = 0;

    // --- UI FUNCTIONS ---
    function setLang(lang) {
        curLang = lang;
        document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-lang-${lang}`).classList.add('active');
        
        document.getElementById('btn-lang-ru').textContent = TEXT[lang].lang_ru;
        document.getElementById('btn-lang-en').textContent = TEXT[lang].lang_en;

        document.getElementById('title-txt').textContent = TEXT[lang].title;
        document.getElementById('btn-easy').textContent = TEXT[lang].easy;
        document.getElementById('btn-norm').textContent = TEXT[lang].norm;
        document.getElementById('btn-hard').textContent = TEXT[lang].hard;
        document.getElementById('lbl-score').textContent = TEXT[lang].score;
        document.getElementById('lbl-moves').textContent = TEXT[lang].moves;
        document.getElementById('lbl-mirrors').textContent = TEXT[lang].mirrors;
        document.getElementById('btn-hint').textContent = TEXT[lang].hint;
        document.getElementById('btn-exit').textContent = TEXT[lang].exit;
        document.getElementById('btn-menu').textContent = TEXT[lang].menu;
        
        document.getElementById('vic-title').textContent = TEXT[lang].vic_title;
        document.getElementById('vic-score-lbl').firstChild.textContent = TEXT[lang].vic_score;
        document.getElementById('vic-moves-lbl').firstChild.textContent = TEXT[lang].vic_moves;
        
        updateMenuRankDisplay();
    }

    function updateMenuRankDisplay() {
        let rIdx = 0;
        for(let i=0; i<RANK_THRESHOLDS.length; i++) {
            if(totalXP >= RANK_THRESHOLDS[i]) rIdx = i;
        }
        
        let curRankName = TEXT[curLang].ranks[rIdx];
        let nextXP = RANK_THRESHOLDS[rIdx+1] || RANK_THRESHOLDS[rIdx] * 1.5;
        let prevXP = RANK_THRESHOLDS[rIdx];
        
        let percent = Math.min(100, Math.max(0, ((totalXP - prevXP) / (nextXP - prevXP)) * 100));
        
        const rankEl = document.getElementById('menu-rank-cur');
        rankEl.textContent = curRankName;
        rankEl.style.color = RANK_COLORS[rIdx];
        
        document.getElementById('menu-xp-bar').style.width = percent + "%";
    }

    function showMenu() {
        document.getElementById('main-menu').style.display = 'flex';
        document.getElementById('game-ui').style.display = 'none';
        document.getElementById('rank-screen').style.display = 'none';
        updateMenuRankDisplay();
        stopGameLoop();
    }

    function startGame(difficulty) {
        curLevelIdx = difficulty;
        const cfg = LEVELS[difficulty];
        boardSize = cfg.size;
        score = cfg.startScore;
        moves = 0;
        isWin = false;
        showHintOverlay = false;
        beamActive = false; 
        startRotation = 0;
        remainingPlaceableMirrors = resolvePlaceableMirrors(cfg.placeableMirrors);
        
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('game-ui').style.display = 'flex';
        
        const boardEl = document.getElementById('game-board');
        boardEl.style.gridTemplateColumns = `repeat(${boardSize}, ${CELL_SIZE}px)`;
        boardEl.style.gridTemplateRows = `repeat(${boardSize}, ${CELL_SIZE}px)`;
        
        const canvas = document.getElementById('beam-canvas');
        canvas.width = boardSize * (CELL_SIZE + GAP);
        canvas.height = boardSize * (CELL_SIZE + GAP);

        updateHUD();
        generateLevel(cfg);
        renderBoard();
        spawnMonsters(cfg.monsterCount);
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width, canvas.height);
        
        stopGameLoop();
        monsterInterval = setInterval(updateMonsters, 2000);
        beamPulse = 0;
        animateBeam();
    }

    function quitGame() {
        showMenu();
    }

    function toggleHint() {
        showHintOverlay = !showHintOverlay;
        if(showHintOverlay) {
             score = Math.max(0, score - 200);
             updateHUD();
        }
    }

    function updateHUD() {
        document.getElementById('score-val').textContent = Math.floor(score);
        document.getElementById('moves-val').textContent = moves;
        document.getElementById('mirrors-val').textContent = remainingPlaceableMirrors;
    }

    function resolvePlaceableMirrors(value) {
        if (typeof value === 'number') return value;
        const min = Math.min(value.min, value.max);
        const max = Math.max(value.min, value.max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getGeneratedMirrorTarget(range) {
        if (!range) return null;
        const min = Math.min(range.min, range.max);
        const max = Math.max(range.min, range.max);
        return { min, max };
    }

    function oppositeDir(dir) {
        if (dir === 'UP') return 'DOWN';
        if (dir === 'DOWN') return 'UP';
        if (dir === 'LEFT') return 'RIGHT';
        return 'LEFT';
    }

    function finishLevel() {
        isWin = true;
        stopGameLoop();
        
        let earnedXP = Math.floor(score * LEVELS[curLevelIdx].xpRewardFactor);
        totalXP += earnedXP;
        localStorage.setItem('mirror_quest_xp_v3', totalXP);
        
        setTimeout(() => {
            document.getElementById('vic-score-val').textContent = Math.floor(score);
            document.getElementById('vic-moves-val').textContent = moves;
            
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('rank-screen').style.display = 'flex';
        }, 1000);
    }

    // --- GENERATION LOGIC (MULTI-PATH) ---

    function generateLevel(cfg) {
        let success = false;
        while (!success) {
            grid = Array(boardSize).fill(null).map(() => Array(boardSize).fill({type: 'EMPTY'}));
            startPos = {x: 0, y: Math.floor(Math.random() * boardSize), dir: 'RIGHT'};
            endPos = {x: boardSize - 1, y: Math.floor(Math.random() * boardSize)};
            startRotation = getRotationForDir(startPos.dir);
            
            // 1. Generate Main Path (Win Condition)
            let path = generatePath(startPos, endPos, cfg.pathLen);
            if (!path) continue;
            if (countMirrors() === 0) continue;
            solutionPath = path; 

            grid[startPos.y][startPos.x] = {type: 'START'};
            grid[endPos.y][endPos.x] = {type: 'END'};

            if (startPos.y === endPos.y) {
                const wallCandidates = [];
                for (let x = startPos.x + 1; x < endPos.x; x++) {
                    if (!path.some(p => p.x === x && p.y === startPos.y)) {
                        wallCandidates.push(x);
                    }
                }
                if (wallCandidates.length === 0) continue;
                const wallX = wallCandidates[Math.floor(Math.random() * wallCandidates.length)];
                grid[startPos.y][wallX] = {type: 'WALL'};
            }

            // 2. Generate Chest Paths (Secondary Objectives)
            chests = [];
            for (let i = 0; i < cfg.chestCount; i++) {
                // Find empty spot for chest
                let cx, cy;
                let attempts = 0;
                do {
                    cx = Math.floor(Math.random() * boardSize);
                    cy = Math.floor(Math.random() * boardSize);
                    attempts++;
                } while ((grid[cy][cx].type !== 'EMPTY' || isNearStart(cx, cy)) && attempts < 50);

                if (grid[cy][cx].type === 'EMPTY') {
                    // Try to generate path FROM CHEST to START (Reverse generation guarantees reachability)
                    // Or FROM CHEST to ANY POINT on MAIN PATH.
                    // Simpler: Just ensure it's not blocked. 
                    // Let's rely on standard noise. If we strictly generate path, it might overwrite mirrors needed for main path.
                    // Instead, we just place chest and hope the "scrambled" mirrors allow reaching it, 
                    // OR we place it near the path.
                    // For "Guaranteed" Chests, we'd need complex branching. 
                    // Current request: "Level generated: reverse path from finish, THEN reverse path from chests".
                    // OK, let's try to add a branch.
                    
                    // We pick a point on the main path, branch out to chest.
                    // But mirrors are already set for main path. We can't change them without breaking main path.
                    // So we must branch from a "Straight" segment of main path, turning it into a Split?
                    // Mirror Protocol doesn't have splitters.
                    // So we must reach chest by diverting beam, then fixing it? No, beam can't split.
                    // Chest is an ALTERNATIVE target. You hit chest, beam stops there. You get points. Then you fix mirrors to hit End.
                    // So we need a path from Start to Chest that shares SOME mirrors but diverges at one point.
                    
                    // Algorithm: 
                    // 1. Pick a cell on main path (pivot).
                    // 2. Change its mirror (temporarily) to divert beam.
                    // 3. Generate path from pivot to Chest.
                    // 4. Revert pivot mirror (so main path works by default or needs rotation).
                    
                    // Simplified for this version: Just place chests randomly. With rotation, player can usually find a way.
                    grid[cy][cx] = {type: 'CHEST', opened: false};
                    chests.push({x: cx, y: cy});
                }
            }

            // 3. Populate Grid
            for(let r=0; r<boardSize; r++){
                for(let c=0; c<boardSize; c++){
                    let cell = grid[r][c];
                    let onPath = path.find(p => p.x === c && p.y === r);
                    
                    if (cell.type === 'EMPTY') {
                        if (!onPath) {
                            let rand = Math.random();
                            if (rand > 0.75) grid[r][c] = {type: 'WALL'};
                            else if (rand > 0.85) grid[r][c] = {type: 'MIRROR', angle: Math.floor(Math.random()*4)};
                        }
                    } else if (cell.type === 'MIRROR') {
                        cell.angle = Math.floor(Math.random()*4); 
                    }
                }
            }
            const mirrorTarget = getGeneratedMirrorTarget(cfg.generatedMirrors);
            if (mirrorTarget) {
                const targetCount = Math.floor(Math.random() * (mirrorTarget.max - mirrorTarget.min + 1)) + mirrorTarget.min;
                let mirrorCount = countMirrors();
                if (mirrorCount > targetCount) {
                    continue;
                }
                if (mirrorCount < targetCount) {
                    const maxAttempts = boardSize * boardSize * 2;
                    let attempts = 0;
                    while (mirrorCount < targetCount && attempts < maxAttempts) {
                        const rx = Math.floor(Math.random() * boardSize);
                        const ry = Math.floor(Math.random() * boardSize);
                        if (grid[ry][rx].type === 'EMPTY' && !isOnSolutionPath(rx, ry)) {
                            grid[ry][rx] = {type: 'MIRROR', angle: Math.floor(Math.random() * 4)};
                            mirrorCount++;
                        }
                        attempts++;
                    }
                    if (mirrorCount < targetCount) {
                        continue;
                    }
                }
            }
            success = true;
        }
    }

    function isNearStart(x, y) {
        const dx = Math.abs(x - startPos.x);
        const dy = Math.abs(y - startPos.y);
        return Math.max(dx, dy) <= 1;
    }

    function countMirrors() {
        let total = 0;
        for (let r = 0; r < boardSize; r++) {
            for (let c = 0; c < boardSize; c++) {
                if (grid[r][c].type === 'MIRROR') total++;
            }
        }
        return total;
    }

    function isOnSolutionPath(x, y) {
        return solutionPath.some(p => p.x === x && p.y === y);
    }

    function generatePath(start, end, minLen) {
        let cur = {x: start.x, y: start.y};
        let dir = start.dir;
        let path = [];
        let steps = 0;
        
        while(!(cur.x === end.x && cur.y === end.y) && steps < 100) {
            path.push({x: cur.x, y: cur.y});
            
            let nextDir = dir;
            
            let nx = cur.x + DIRS[dir].dx;
            let ny = cur.y + DIRS[dir].dy;
            
            if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize || Math.random() > 0.6) {
                let turns = [];
                if (dir === 'RIGHT' || dir === 'LEFT') turns = ['UP', 'DOWN'];
                else turns = ['LEFT', 'RIGHT'];
                nextDir = turns[Math.floor(Math.random()*2)];
                
                if (!(cur.x === start.x && cur.y === start.y)) {
                     grid[cur.y][cur.x] = {type: 'MIRROR', angle: 0};
                }
                dir = nextDir;
            }
            
            cur.x += DIRS[dir].dx;
            cur.y += DIRS[dir].dy;
            
            if (cur.x < 0 || cur.x >= boardSize || cur.y < 0 || cur.y >= boardSize) return null;
            steps++;
        }
        
        if (steps < minLen) return null;
        return path;
    }

    // --- MONSTERS & CHESTS ---
    function spawnMonsters(count) {
        monsters = [];
        const layer = document.getElementById('monsters-layer');
        layer.innerHTML = '';
        
        for(let i=0; i<count; i++) {
            let mx, my;
            do {
                mx = Math.floor(Math.random() * boardSize);
                my = Math.floor(Math.random() * boardSize);
            } while(grid[my][mx].type !== 'EMPTY');
            
            let el = document.createElement('div');
            el.className = 'monster';
            el.textContent = 'ðŸ‘¾';
            el.style.left = (mx * (CELL_SIZE+GAP) + 10) + 'px';
            el.style.top = (my * (CELL_SIZE+GAP) + 10) + 'px';
            layer.appendChild(el);
            const patrolRoute = buildPatrolRoute(mx, my);
            monsters.push({x: mx, y: my, el: el, dead: false, route: patrolRoute, routeIndex: 0});
        }
    }

    function buildPatrolRoute(startX, startY) {
        const directions = [
            {x: 0, y: -1},
            {x: 0, y: 1},
            {x: -1, y: 0},
            {x: 1, y: 0}
        ];
        directions.sort(() => Math.random() - 0.5);

        for (const dir of directions) {
            const length = 2 + Math.floor(Math.random() * 4);
            const forward = [{x: startX, y: startY}];
            let valid = true;
            for (let step = 1; step <= length; step++) {
                const nx = startX + dir.x * step;
                const ny = startY + dir.y * step;
                if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize) {
                    valid = false;
                    break;
                }
                if (grid[ny][nx].type !== 'EMPTY') {
                    valid = false;
                    break;
                }
                forward.push({x: nx, y: ny});
            }
            if (!valid || forward.length < 2) continue;

            const backward = forward.slice(1, -1).reverse();
            return forward.concat(backward);
        }

        return [{x: startX, y: startY}];
    }

    function updateMonsters() {
        if (isWin) return;
        monsters.forEach(m => {
            if (m.dead) return;
            if (!m.route || m.route.length === 0) return;
            m.routeIndex = (m.routeIndex + 1) % m.route.length;
            const next = m.route[m.routeIndex];
            if (grid[next.y][next.x].type === 'EMPTY') {
                m.x = next.x; m.y = next.y;
                m.el.style.left = (m.x * (CELL_SIZE+GAP) + 10) + 'px';
                m.el.style.top = (m.y * (CELL_SIZE+GAP) + 10) + 'px';
            }
        });
    }
    
    function stopGameLoop() {
        if (monsterInterval) clearInterval(monsterInterval);
        if (beamAnimFrame) cancelAnimationFrame(beamAnimFrame);
    }

    function killMonster(m) {
        if (m.dead) return;
        m.dead = true;
        m.el.classList.add('dead');
        score += 500;
        showFloatText(m.el.style.left, m.el.style.top, "+500");
        updateHUD();
    }
    
    function openChest(r, c) {
        let cell = grid[r][c];
        if (cell.type === 'CHEST' && !cell.opened) {
            cell.opened = true;
            score += 2000;
            
            // Visual Update
            let dom = document.querySelector(`.chest[data-r="${r}"][data-c="${c}"]`);
            if (dom) dom.classList.add('open');
            
            // Float text
            let left = (c * (CELL_SIZE+GAP) + 10) + 'px';
            let top = (r * (CELL_SIZE+GAP) + 10) + 'px';
            showFloatText(left, top, "+2000", "#ffd700");
            
            updateHUD();
        }
    }
    
    function showFloatText(left, top, text, color="#ff0") {
        let float = document.createElement('div');
        float.className = 'float-score';
        float.textContent = text;
        float.style.color = color;
        float.style.left = left;
        float.style.top = top;
        document.getElementById('monsters-layer').appendChild(float);
        setTimeout(() => float.remove(), 1000);
    }

    // --- RENDER & ANIMATION ---
    
    function animateBeam() {
        if(beamActive) {
            beamPulse += 0.05;
            traceBeam();
        }
        beamAnimFrame = requestAnimationFrame(animateBeam);
    }
    
    function getRotationForDir(dir) {
        if (dir === 'UP') return 270;
        if (dir === 'RIGHT') return 0;
        if (dir === 'DOWN') return 90;
        return 180;
    }

    function applyStartRotation(iconEl) {
        if (iconEl) {
            iconEl.style.setProperty('--start-rotate', `${startRotation}deg`);
        }
    }

    function setStartDir(dir) {
        startPos.dir = dir;
        startRotation = getRotationForDir(dir);
        const iconEl = document.querySelector('.start-icon');
        applyStartRotation(iconEl);
        if (!beamActive) beamActive = true;
        traceBeam();
    }

    function rotateStartIcon() {
        const currentIndex = DIR_NAMES.indexOf(startPos.dir);
        const nextDir = DIR_NAMES[(currentIndex + 1) % DIR_NAMES.length];
        setStartDir(nextDir);
    }

    function getBeamOrigin() {
        const baseX = startPos.x * (CELL_SIZE + GAP) + CELL_SIZE / 2;
        const baseY = startPos.y * (CELL_SIZE + GAP) + CELL_SIZE / 2;
        return { x: baseX, y: baseY };
    }

    function clickCell(r, c) {
        if (isWin) return;
        if (!beamActive) beamActive = true; 

        let cell = grid[r][c];
        
        if (cell.type === 'MIRROR') {
            cell.angle = (cell.angle + 1) % 4;
            moves++;
            score = Math.max(0, score - LEVELS[curLevelIdx].moveCost);
            updateHUD();
            let dom = document.querySelector(`.mirror[data-r="${r}"][data-c="${c}"]`);
            if (dom) dom.dataset.angle = cell.angle;
        }
    }
    
    function placeMirror(r, c) {
        if (isWin) return;
        if (!beamActive) beamActive = true; 
        if (remainingPlaceableMirrors <= 0) return;
        const cell = grid[r][c];
        if (cell.type !== 'EMPTY') return;
        grid[r][c] = {type: 'MIRROR', angle: 0};
        remainingPlaceableMirrors--;
        moves++;
        score = Math.max(0, score - LEVELS[curLevelIdx].moveCost);
        updateHUD();
        renderBoard();
    }

    function renderBoard() {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        for (let r = 0; r < boardSize; r++) {
            for (let c = 0; c < boardSize; c++) {
                const cellData = grid[r][c];
                const div = document.createElement('div');
                div.className = 'cell';
                div.style.width = CELL_SIZE + 'px';
                div.style.height = CELL_SIZE + 'px';
                if (cellData.type === 'START') {
                    div.innerHTML = `
                        <div class="start-container">
                            <div class="start-icon">
                                <span class="icon-stack">
                                    <span class="icon-core icon-base">âš¡</span>
                                    <span class="icon-core icon-rotated">âš¡</span>
                                </span>
                            </div>
                            <div class="start-arrows">
                                <div class="arrow-btn arr-up" onclick="event.stopPropagation(); setStartDir('UP')">â–²</div>
                                <div class="arrow-btn arr-down" onclick="event.stopPropagation(); setStartDir('DOWN')">â–¼</div>
                                <div class="arrow-btn arr-left" onclick="event.stopPropagation(); setStartDir('LEFT')">â—€</div>
                                <div class="arrow-btn arr-right" onclick="event.stopPropagation(); setStartDir('RIGHT')">â–¶</div>
                            </div>
                        </div>
                    `;
                    const iconEl = div.querySelector('.start-icon');
                    applyStartRotation(iconEl);
                    iconEl.addEventListener('click', (event) => {
                        event.stopPropagation();
                        rotateStartIcon();
                    });
                }
                else if (cellData.type === 'END') div.innerHTML = '<div class="end">ðŸ’Ž</div>';
                else if (cellData.type === 'WALL') div.innerHTML = '<div class="wall"></div>';
                else if (cellData.type === 'CHEST') {
                    const openClass = cellData.opened ? ' open' : '';
                    div.innerHTML = `<div class="chest${openClass}" data-r="${r}" data-c="${c}">ðŸ§°</div>`;
                }
                else if (cellData.type === 'MIRROR') {
                    const m = document.createElement('div');
                    m.className = 'mirror';
                    m.dataset.angle = cellData.angle;
                    m.dataset.r = r;
                    m.dataset.c = c;
                    div.appendChild(m);
                    div.onclick = () => clickCell(r, c);
                }
                else if (cellData.type === 'EMPTY') {
                    div.onclick = () => placeMirror(r, c);
                }
                boardEl.appendChild(div);
            }
        }
    }

    function traceBeam() {
        const canvas = document.getElementById('beam-canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const startIcon = document.querySelector('.start-icon');
        if (startIcon) {
            startIcon.classList.toggle('beam-active', beamActive);
        }

        if (!beamActive) return;

        document.querySelectorAll('.mirror.reflecting').forEach(el => el.classList.remove('reflecting'));

        if (showHintOverlay && solutionPath.length > 0) {
            ctx.strokeStyle = 'rgba(0, 210, 255, 0.3)';
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.beginPath();
            let sx = startPos.x * (CELL_SIZE + GAP) + CELL_SIZE/2;
            let sy = startPos.y * (CELL_SIZE + GAP) + CELL_SIZE/2;
            ctx.moveTo(sx, sy);
            for(let p of solutionPath) {
                 let px = p.x * (CELL_SIZE + GAP) + CELL_SIZE/2;
                 let py = p.y * (CELL_SIZE + GAP) + CELL_SIZE/2;
                 ctx.lineTo(px, py);
            }
            ctx.stroke();
        }

        let widthVar = Math.sin(beamPulse) * 1.5 + 4; 
        let hueShift = (beamPulse * 20) % 360; 
        
        ctx.strokeStyle = `hsl(${hueShift}, 80%, 60%)`;
        ctx.lineWidth = widthVar;
        ctx.shadowBlur = 15;
        ctx.shadowColor = `hsl(${hueShift}, 80%, 50%)`;
        ctx.lineCap = 'round';
        ctx.beginPath();
        
        const origin = getBeamOrigin();
        ctx.moveTo(origin.x, origin.y);
        
        let lx = startPos.x, ly = startPos.y, lDir = startPos.dir;
        let steps = 0, hitEnd = false;
        
        while (steps < 200) {
            lx += DIRS[lDir].dx;
            ly += DIRS[lDir].dy;
            
            monsters.forEach(m => {
                if (!m.dead && m.x === lx && m.y === ly) killMonster(m);
            });

            if (lx < 0 || lx >= boardSize || ly < 0 || ly >= boardSize) break;
            
            let nx = lx * (CELL_SIZE + GAP) + CELL_SIZE/2;
            let ny = ly * (CELL_SIZE + GAP) + CELL_SIZE/2;
            
            let wiggle = Math.sin(beamPulse * 3 + steps) * 2;
            let wx = nx, wy = ny;
            if (lDir === 'LEFT' || lDir === 'RIGHT') wy += wiggle;
            else wx += wiggle;

            ctx.lineTo(wx, wy);
            
            const cell = grid[ly][lx];
            if (cell.type === 'WALL') break;
            if (cell.type === 'CHEST') openChest(ly, lx);
            if (cell.type === 'END') { hitEnd = true; break; }
            
            if (cell.type === 'MIRROR') {
                const mirrorEl = document.querySelector(`.mirror[data-r="${ly}"][data-c="${lx}"]`);
                if (mirrorEl) mirrorEl.classList.add('reflecting');
                const mirrorAngle = cell.angle % 2;
                if (mirrorAngle === 0) { 
                    if (lDir === 'RIGHT') lDir = 'DOWN';
                    else if (lDir === 'DOWN') lDir = 'RIGHT';
                    else if (lDir === 'LEFT') lDir = 'UP';
                    else if (lDir === 'UP') lDir = 'LEFT';
                } else { 
                    if (lDir === 'RIGHT') lDir = 'UP';
                    else if (lDir === 'UP') lDir = 'RIGHT';
                    else if (lDir === 'LEFT') lDir = 'DOWN';
                    else if (lDir === 'DOWN') lDir = 'LEFT';
                }
                lDir = oppositeDir(lDir);
            }
            steps++;
        }
        
        ctx.stroke();
        
        const endCell = document.querySelector('.end');
        if (hitEnd && !isWin) {
            endCell.classList.add('lit');
            ctx.strokeStyle = '#00ffaa';
            ctx.shadowColor = '#00ffaa';
            ctx.stroke();
            finishLevel();
        } else if (!isWin && endCell) {
            endCell.classList.remove('lit');
        }
    }
    
    setLang('ru');
    updateMenuRankDisplay();

</script>
</body>
</html>
